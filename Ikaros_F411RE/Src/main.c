/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include "system_settings.h"
#include "gpios.h"
#include "stepper_motor.h"
#include "keypad_4x4.h"
#include "timers.h"
#include "lcd.h"
#include "adc.h"
#include "uart.h"
#include "watchdog.h"
#include "state_machine.h"

#include "../Inc/Drivers/i2c.h"

#include "../Inc/Peripherals/SHT20.h"
#include "../Inc/Peripherals/BMI160.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int main(void){

	i2c_config_parameters_t I2C_config;
	Status_code_t status =Success;
	uint8_t chip_id =0;
	int16_t temperature =0;
	PMU_status_t accelerometer  = Normal;
	PMU_status_t Gyroscope 		= Normal;
	PMU_status_t magnetomer 	= Normal;

	I2C_config.baudrate = FastMode_400Kbps;
	I2C_config.duty = duty_2_1;

	I2C1_Init_Master(I2C_config);

	status = BMI160_Chip_ID(I2C1_Alt, &chip_id);

	status =  BMI160_Temperature(I2C1_Alt,&temperature);

	status = BMI160_PMU_Status(I2C1_Alt, &accelerometer, &Gyroscope, &magnetomer);


	status =  BMI160_Set_Acceleromete_PM(I2C1_Alt, Acc_Normal);

	status =  BMI160_Set_Gyroscope_PM(I2C1_Alt, Gyr_Normal);

	status =  BMI160_Set_Magnetometer_PM(I2C1_Alt, Mag_Normal);

	status = BMI160_PMU_Status(I2C1_Alt, &accelerometer, &Gyroscope, &magnetomer);

	status =  BMI160_Temperature(I2C1_Alt,&temperature);

	while(1);
	return 0;
}



//int main(void){
//
//i2c_config_parameters_t I2C_config;
//Status_code_t status =Success;
//uint16_t humedad =0;
//int16_t temperature =0;
//
//
//	I2C_config.baudrate = FastMode_400Kbps;
//	I2C_config.duty = duty_2_1;
//
//	I2C1_Init_Master(I2C_config);
//
//
//	while(1){
//	status = SHT20ReadHumedad(I2C1_Alt, &humedad);
//	Delay(5000);
//
//	status = SHT20ReadTemperature(I2C1_Alt, &temperature);
//	Delay(5000);
//
//	}
//
//	return 0;
//}


















// funciones para leer la temperatura
//int main(void){
//
////	runMachine();
//	uint32_t tempre =0;
//	float cels =0.0f;
//
//	ADC_Init_Temperature_Sensor(RES_12_bits);
//
//
//	while(1){
//		tempre =0;
//
//		ADC_Read_Temperature(&tempre);
//
//		cels = (float)(tempre/100.0f);
//		tempre =0;
//	}
//
//	return 0;
//}




//_____________________________________________________________


////
////usart_synchronous_config_t syncronous_conf = {CPOL_low, CPHA_second_edge,LBCL_not_output};
////
////usart_config_t usart_config={
////		9600,
////		Synchronous,
////		&syncronous_conf,
////		enable_TX_and_RX,
////		None,
////		Data_8_bits,
////		Stop_1_bits
////};
//
//usart_config_t usart_config={
//		9600,
//		Asynchronous, //pendiente  y las demas configuraciones
//		NULL,
//		enable_TX_and_RX,
//		None,
//		Data_8_bits,
//		Stop_1_bits
//};
//
////usart_INT_config_t usart_int_conf={
////		9600,
////		None,
////		Data_8_bits,
////		Stop_1_bits
////};
//
//
//WWDG_config_t WWDog ={
//		100,
//		40,
//		1
//};
//
////int main(void){
////	Init_Board();
////	Init_UART2(usart_config);
////	bool wwdst_reg = RCC_get_reset_status_flag(RCC_WWDGRSTF);
////
//////	Delay(200000);
//////	UART2_Write("\r\n",2,2000);
////
//////	SetPinMode(Port_C, Pin_13, Input);
//////	SetPinMode(Port_A, Pin_5, Output);
////////
//////	Delay(100000);
//////	GPIO_DigitalWrite(Port_A, Pin_5, High);
//////
//////	Init_Win_Watchdog(WWDog);
////
////	while(1){
////
//////		Delay(70000);
//////		Win_Watchdog_control(reload_food);
//////
//////
//////		if(!GPIO_DigitalRead(Port_C, Pin_13)){
//////			while(1);
//////		}
////
////	}
////
////	return 0;
////}
//
////
//////volver a checar lo del wwdg para ver si el init esta bien
//int main(void){
//	Init_Board();
////	uint8_t data[100]={0};
////	uint8_t data_rx_buff[100]={0};
////	uint32_t data_lenght=0;
////	bool wwdst_reg = RCC_get_reset_status_flag(RCC_WWDGRSTF);
//
////		Init_UART2(usart_config);
//		Init_UART2_RX_Interrupt(usart_config);
//	while(1){
//
//		Delay(200000);
////		UART2_Write("inicio\n",7,2000);
////
////		UART2_Read(data,&data_lenght,2000);
////
////		UART2_Read_bytes(data_rx_buff,5,2000);
//
//
//	}
//
//	return 0;
//}




