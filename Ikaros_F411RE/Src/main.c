/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include "system_settings.h"
#include "gpios.h"
#include "stepper_motor.h"
#include "keypad_4x4.h"
#include "timers.h"
#include "lcd.h"
#include "adc.h"
#include "uart.h"
#include "watchdog.h"
#include "state_machine.h"
#include "i2c.h"
#include "SHT20.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


int main(void){

i2c_config_parameters_t I2C_config;
Status_code_t status =Success;
uint16_t humedad =0;
int16_t temperature =0;


I2C_config.baudrate = FastMode_400Kbps;
I2C_config.duty = duty_2_1;

	I2C1_Init_Master(I2C_config);


	while(1){
	status = SHT20ReadHumedad(I2C1_Alt, &humedad);

	status = SHT20ReadTemperature(I2C1_Alt, &temperature);

	}

	return 0;
}


















// funciones para leer la temperatura
//int main(void){
//
////	runMachine();
//	uint32_t tempre =0;
//	float cels =0.0f;
//
//	ADC_Init_Temperature_Sensor(RES_12_bits);
//
//
//	while(1){
//		tempre =0;
//
//		ADC_Read_Temperature(&tempre);
//
//		cels = (float)(tempre/100.0f);
//		tempre =0;
//	}
//
//	return 0;
//}




//_____________________________________________________________


////
////usart_synchronous_config_t syncronous_conf = {CPOL_low, CPHA_second_edge,LBCL_not_output};
////
////usart_config_t usart_config={
////		9600,
////		Synchronous,
////		&syncronous_conf,
////		enable_TX_and_RX,
////		None,
////		Data_8_bits,
////		Stop_1_bits
////};
//
//usart_config_t usart_config={
//		9600,
//		Asynchronous, //pendiente  y las demas configuraciones
//		NULL,
//		enable_TX_and_RX,
//		None,
//		Data_8_bits,
//		Stop_1_bits
//};
//
////usart_INT_config_t usart_int_conf={
////		9600,
////		None,
////		Data_8_bits,
////		Stop_1_bits
////};
//
//
//WWDG_config_t WWDog ={
//		100,
//		40,
//		1
//};
//
////int main(void){
////	Init_Board();
////	Init_UART2(usart_config);
////	bool wwdst_reg = RCC_get_reset_status_flag(RCC_WWDGRSTF);
////
//////	Delay(200000);
//////	UART2_Write("\r\n",2,2000);
////
//////	SetPinMode(Port_C, Pin_13, Input);
//////	SetPinMode(Port_A, Pin_5, Output);
////////
//////	Delay(100000);
//////	GPIO_DigitalWrite(Port_A, Pin_5, High);
//////
//////	Init_Win_Watchdog(WWDog);
////
////	while(1){
////
//////		Delay(70000);
//////		Win_Watchdog_control(reload_food);
//////
//////
//////		if(!GPIO_DigitalRead(Port_C, Pin_13)){
//////			while(1);
//////		}
////
////	}
////
////	return 0;
////}
//
////
//////volver a checar lo del wwdg para ver si el init esta bien
//int main(void){
//	Init_Board();
////	uint8_t data[100]={0};
////	uint8_t data_rx_buff[100]={0};
////	uint32_t data_lenght=0;
////	bool wwdst_reg = RCC_get_reset_status_flag(RCC_WWDGRSTF);
//
////		Init_UART2(usart_config);
//		Init_UART2_RX_Interrupt(usart_config);
//	while(1){
//
//		Delay(200000);
////		UART2_Write("inicio\n",7,2000);
////
////		UART2_Read(data,&data_lenght,2000);
////
////		UART2_Read_bytes(data_rx_buff,5,2000);
//
//
//	}
//
//	return 0;
//}




